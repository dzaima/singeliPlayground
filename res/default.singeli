include 'skin/c'
include 'arch/c'
oper ~~ reinterpret infix right 55
def isintv{T} = isint{eltype{T}}
def isf64v{T} = f64==eltype{T}
def load {a:T, n    & width{eltype{T}}==256 & isintv{eltype{T}}} = emit{eltype{T}, '_mm256_loadu_si256',    emit{T, 'op +', a, n}}
def load {a:T, n    & width{eltype{T}}==256 & isf64v{eltype{T}}} = emit{eltype{T}, '_mm256_loadu_pd', *f64~~emit{T, 'op +', a, n}}
def store{a:T, n, v & width{eltype{T}}==256 & isintv{eltype{T}}} = emit{void, '_mm256_storeu_si256',        emit{T, 'op +', a, n}, v}
def store{a:T, n, v & width{eltype{T}}==256 & isf64v{eltype{T}}} = emit{void, '_mm256_storeu_pd',     *f64~~emit{T, 'op +', a, n}, v}
def __add{a:T,b:T & T==[8]i32} = emit{T, '_mm256_add_epi32', a, b}

fn f(x:*[8]i32) = load{x,10}+emit{[8]i32, '_mm256_set1_epi32', 1}
export{'f', f}

⍎

# 'name ← expression' to update watch
# 'name:← expression' to set only if name doesn't already exist
# variables from a watch can be read as regular variables
c:← i32~~1
c = c+1
data:*i32 = tup{0,1,2,3,4,5,6,7}

a ← emit{[8]i32, '_mm256_set1_epi32', 1000}
b ← a + load{*[8]i32~~data, 0}
